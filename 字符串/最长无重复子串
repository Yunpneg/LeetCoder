给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

* 窗口内的都是没有重复的字符，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以我们只关心每个字符最后出现的位置，并建立映射。
* 窗口的右边界就是当前遍历到的字符的位置为了求出窗口的大小，我们需要一个变量left来指向滑动窗口的左边界 
* 如果当前遍历到的字符从未出现过，那么直接扩大右边界，如果之前出现过，那么就分两种情况 
    * 如果不在滑动窗口内，当前字符可以加进来 
    * 如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位一位向右遍历查找，由于我们的HashMap已经保存了该重复字符最后出现的位置，所以直接移动left指针就可以了, 也就是将map中已经记录的该重复字符的位置赋给指针left 
    * 要维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果了


解题:
* 建立一个256位大小的整型数组来代替哈希表，这样做的原因是ASCII表共能表示256个字符，所以可以记录所有字符，然后我们需要定义两个变量res和left，其中res用来记录最长无重复子串的长度，left指向该无重复子串左边的起始位置，然后我们遍历整个字符串，对于每一个遍历到的字符
* 计算最长无重复子串
    * 如果哈希表中该字符串对应的值为0，说明没有遇到过该字符，则此时计算最长无重复子串
    * 当哈希表中的值小于left，这是由于此时出现过重复的字符，left的位置更新了，如果又遇到了新的字符，就要重新计算最长无重复子串.
    * i - left + 1
        * i 是当前字符的位置, 也是窗口右边界的位置
        * left是窗口左边界的位置
        * 加1是因为上述是下标, 具体长度要加上1
* 更新left
    * 如果遇到重复字符, 则将哈希表中的重复字符的位置赋予left
    * left = m[s[i]]
* 每次循环后, 都要讲当前字符对应的值赋值为i+1(下标的具体长度)
    * m[s[i]] = i + 1
    
    
    

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int left=0, res=0, m[256]={0};
        for(int i=0; i<s.size(); i++)
        {
            if(m[s[i]] == 0 || m[s[i]] < left)
            {
                //计算长度
                res = max(res, i - left + 1);
            }
            else
            {
                //更新left, 遇到了重复元素
                left = m[s[i]];
            }
            //更新哈希表中的键值,对应不同的字符
            m[s[i]] = i+1;
        }
        return res;
    }
};
